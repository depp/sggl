# Copyright 2014-2015 Dietrich Epp.
# This file is part of SGGL.  SGGL is licensed under the terms of the
# 2-clause BSD license.  For more information, see LICENSE.txt.
import os
import xml.etree.ElementTree as etree
import collections
import io
import re

API_LIST = 'gl:core', 'gl:compatibility', 'gles1', 'gles2'

NOTICE = '/* This file is automatically generated.  */\n'

COMMON_HEADER = '''\
#ifndef SG_GL_COMMON_H
#define SG_GL_COMMON_H
#include "sg/defs.h"

#if defined __cplusplus
# define SG_GL_EXTC extern "C"
#else
# define SG_GL_EXTC
#endif
#if defined _WIN32
# define SG_GL_API __stdcall
# define SG_GL_IMPORT SG_GL_EXTC __declspec(dllimport)
#else
# define SG_GL_API
# define SG_GL_IMPORT SG_GL_EXTC
#endif
'''

COMMON_FOOTER = '''\
#ifdef __cplusplus
extern "C" {
#endif

/* The version of the active context, in BCD.  */
extern int sg_glver;

/* List of all OpenGL versions with emitted interfaces, in BCD.  */
extern const unsigned char SG_GL_VERSIONS[SG_GL_VERSIONCOUNT];

/* Flags for which extensions are available.  */
#if defined SG_GL_HASEXTS
extern unsigned sg_glext[(SG_GL_EXTCOUNT + 31) / 32];
#endif

/* Pointers to OpenGL entry points.  */
extern void *sg_glfunc[SG_GL_ENTRYCOUNT];

#ifdef __cplusplus
}
#endif

#endif
'''

IFACE_HEADER = '''\
#ifndef {info.guard}_H
#define {info.guard}_H
#include "common.h"
'''

IFACE_FOOTER = '''\
#ifdef __cplusplus
}
#endif
#endif
'''

COMMAND_DIRECT = '''\
SG_GL_IMPORT {type} SG_GL_API gl{name}({params});
'''

COMMAND_INDIRECT = '''\
SG_INLINE {type} gl{name}({params}) {{ \
{retstmt}(({type} (SG_GL_API*)({ptypes}))\
(sg_glfunc[{index}]))({pnames}); \
}}
'''

Type = collections.namedtuple('Type', 'name definition requires')
Function = collections.namedtuple('Function', 'proto params')
Parameter = collections.namedtuple('Parameter', 'name fulltype typename')
InterfaceName = collections.namedtuple(
    'InterfaceName', 'category info profile')

def flat_text(node, tagmap={}):
    """Flatten XML tree, returning just the text."""
    fp = io.StringIO()
    def visit(node):
        try:
            fp.write(tagmap[node.tag])
            return
        except KeyError:
            pass
        if node.text:
            fp.write(node.text)
        for child in node:
            visit(child)
            if child.tail:
                fp.write(child.tail)
    visit(node)
    return fp.getvalue()

def xml_info(node):
    """Print a lists of tags and attributes in an XML tree."""
    tags = set()
    attrib = set()
    def scan(node):
        tags.add(node.tag)
        attrib.update(node.attrib)
        for child in node:
            scan(child)
    scan(node)
    print('Tags:', ' '.join(sorted(tags)))
    print('Attributes:', ' '.join(sorted(attrib)))

def get_param(node):
    """Get a type/name from an XML tree."""
    if len(node) == 1:
        name, = node
        fulltype = [node.text]
        typename = None
    elif len(node) == 2:
        ptype, name = node
        assert ptype.tag == 'ptype'
        typename = ptype.text
        fulltype = [node.text, typename, ptype.tail]
    else:
        assert False
    fulltype = ''.join(x or '' for x in fulltype).strip()
    assert name.tag == 'name'
    name = name.text
    return Parameter(name, fulltype, typename)

def cmd_name(name):
    """Shorten a command name."""
    assert name.startswith('gl')
    return name[2:]

def enum_name(name):
    """Shorten an enumeration name."""
    assert name.startswith('GL_')
    return name[3:]

DIGITCHUNK = re.compile('(\D*)(\d*)')
def sort_key(name):
    """Get the sort key for text containing numbers."""
    ms = DIGITCHUNK.findall(name)
    parts = []
    for x, y in ms:
        if not (x or y):
            break
        parts.append(x)
        if not y:
            break
        parts.append(int(y))
    return tuple(parts)

def profile_key(prof):
    """Get the sort key for profiles."""
    if prof == 'core':
        return (0, prof)
    return (1, prof)

def ext_key(name):
    """Get the sort key for extensions."""
    i = name.find('_')
    if i >= 0:
        k = name[:i]
        if k in ('ARB', 'KHR', 'OES'):
            return (0, name)
    return (1, name)

def encode_version(v):
    x, y = v
    assert 0 <= x and 0 <= y <= 15
    return '0x{:x}'.format(x * 16 + y)

class Registry(object):
    """OpenGL registry."""
    __slots__ = ['types', 'groups', 'enum_groups', 'enums', 'commands',
                 'features', 'extensions', 'api', 'profile',
                 'dependencies']

    def __init__(self, api, profile):
        self.types = []
        self.groups = {}
        self.enum_groups = {}
        self.enums = {}
        self.commands = {}
        self.features = {}
        self.extensions = {}
        self.api = api
        self.profile = profile
        self.dependencies = [__file__]

    @classmethod
    def load(class_, path, api, profile):
        """Load the OpenGL registry file from XML."""
        if path is None:
            path = os.path.join(os.path.dirname(__file__), 'gl.xml')
        obj = class_(api, profile)
        obj.dependencies.append(path)
        tree = etree.parse(path)
        for e in tree.getroot():
            try:
                func = getattr(obj, '_read_' + e.tag)
            except AttributeError:
                raise ValueError('Unknown tag: {}'.format(e.tag))
            func(e)
        return obj

    def _read_comment(self, node):
        """Read a top-level comment tag."""
        pass

    def _read_types(self, node):
        """Read a top-level types tag."""
        tagmap = {'apientry': 'SG_GL_API'}
        for child in node:
            assert child.tag == 'type'
            if child.attrib.get('api', 'gl') != self.api:
                continue
            try:
                name = child.attrib['name']
            except KeyError:
                for e in child:
                    if e.tag == 'name':
                        name = e.text
                        break
                else:
                    assert False
            self.types.append(Type(
                name,
                flat_text(child, tagmap),
                child.attrib.get('requires')))

    def _read_groups(self, node):
        """Read a top-level groups tag."""
        for child in node:
            assert child.tag == 'group'
            gname = child.attrib['name']
            assert gname not in self.groups
            group = []
            self.groups[gname] = group
            for child2 in child:
                group.append(enum_name(child2.attrib['name']))

    def _read_enums(self, node):
        """Read a top-level enums tag."""
        gname = (node.attrib['namespace'], node.attrib.get('group', '-'))
        try:
            gdata = self.enums[gname]
        except KeyError:
            gdata = {}
            self.enums[gname] = gdata
        for child in node:
            if child.tag != 'enum':
                assert child.tag == 'unused'
                continue
            value = int(child.attrib['value'], 0)
            gdata[enum_name(child.attrib['name'])] = value
        self.enums.update(gdata)

    def _read_commands(self, node):
        """Read a top-level commands tag."""
        for child in node:
            assert child.tag == 'command'
            assert len(child) > 0
            assert child[0].tag == 'proto'
            proto = get_param(child[0])
            params = []
            for child2 in child[1:]:
                if child2.tag == 'param':
                    params.append(get_param(child2))
                else:
                    assert child2.tag in ('glx', 'vecequiv', 'alias')
            name = cmd_name(proto.name)
            assert name not in self.commands
            self.commands[name] = Function(proto, params)

    def _read_feature(self, node):
        """Read a top-level feature tag."""
        if node.attrib['api'] != self.api:
            return
        version = node.attrib['number']
        i = version.index('.')
        version = int(version[:i]), int(version[i+1:])
        self.features[version] = node

    def _read_extensions(self, node):
        """Read a top-level extensions tag."""
        for child in node:
            supported = child.attrib['supported'].split('|')
            if self.api not in supported:
                continue
            name = child.attrib['name']
            self.extensions[enum_name(name)] = child

    def get_platform_info(self, platform):
        if not re.match(r'^\w+$', platform):
            raise ValueError('Invalid platform: {!r}'.format(platform))
        path = os.path.join(
            os.path.dirname(__file__), platform + '.txt')
        try:
            fp = open(path)
        except FileNotFoundError:
            raise ValueError('Unsupported platform: {}'.format(platform))
        def die(msg):
            raise Exception('{}:{}: {}'.format(path, lineno, msg))
        with fp:
            lines = enumerate(fp, 1)
            version = None
            myapi = self.api, self.profile
            for lineno, line in lines:
                fields = line.split()
                if not fields:
                    break
                if len(fields) != 2:
                    die('must have two fields')
                if fields[0] not in API_LIST:
                    die('invalid API')
                api = parse_api(fields[0])
                if myapi == api:
                    try:
                        version = parse_version(fields[1])
                    except ValueError:
                        die('invalid version number')
            if not version:
                raise ValueError(
                    'No data for this API and platform: {}, {!r}'
                    .format(platform, myapi))
            exts = []
            for lineno, line in lines:
                line = line.strip()
                if line:
                    exts.append(line)
        return version, exts, [path]

    def get_data(self, *, max_version, extensions=[], platform):
        """Get the C and C++ header data.

        Returns (deps, data), where deps is a list of files used to
        generate the data, and data is a dictionary mapping file names
        to file contents (bytes).
        """
        deps = list(self.dependencies)
        files = {}
        decl_version, decl_extensions, decl_deps = \
            self.get_platform_info(platform)
        deps.extend(decl_deps)
        del decl_deps

        # Validate input
        if max_version not in self.features:
            raise ValueError('No such version: {}.{}'.format(*max_version))
        versions = [version for version in sorted(self.features)
                    if version <= max_version]
        extensions = sorted(extensions, key=ext_key)

        # Create list of interfaces
        ifaces = (
            [self._get_core(version, version <= decl_version)
             for version in versions] +
            [self._get_extension(extension, extension in decl_extensions)
             for extension in extensions])

        # Emit all interface headers, assign commands to numbers
        command_dict = {}
        command_list = []
        for iface in ifaces:
            if not iface.declare:
                continue
            for command in iface.commands:
                command_dict[command] = None
        for n, iface in enumerate(ifaces):
            for command in sorted(iface.commands):
                if command not in command_dict:
                    command_dict[command] = len(command_list)
                    command_list.append(command)
            file = io.StringIO()
            iface.dump(file, ifaces[:n], command_dict)
            files[iface.filename] = file.getvalue()

        file = io.StringIO()
        self._dump_common(file, versions, extensions,
                          command_list, command_dict.keys())
        files['common.h'] = file.getvalue()

        file = io.StringIO()
        self._dump_data(file, versions, extensions, command_list)
        files['opengl_data.c'] = file.getvalue()

        data = {name: value.encode('ASCII')
                for name, value in files.items()}
        return deps, data

    def _dump_common(self, file, versions, extensions, command_list,
                     all_commands):
        file.write(NOTICE)
        file.write(COMMON_HEADER)

        print(file=file)

        # Write OpenGL types
        required = set()
        for cmd in all_commands:
            cmd = self.commands[cmd]
            required.add(cmd.proto.typename)
            required.update(p.typename for p in cmd.params)
        update = True
        require_map = {type.name: type.requires for type in self.types}
        required.discard(None)
        while update:
            update = False
            for type in list(required):
                requires = require_map[type]
                if requires is None or requires in required:
                    continue
                required.add(requires)
                update = True
        for type in self.types:
            if type.name in required:
                print(type.definition, file=file)

        print(file=file)

        file.write(
            'enum {{\n'
            '    SG_GL_VERSIONCOUNT = {},\n'
            '    SG_GL_EXTCOUNT = {},\n'
            '    SG_GL_ENTRYCOUNT = {}\n'
            '}};\n'
            '\n'
            .format(len(versions), len(extensions), len(command_list)))

        for version in versions:
            print('#define SG_GL_VERSION_{0[0]}_{0[1]} '
                  '(sg_glver >= {1})'
                  .format(version, encode_version(version)),
                  file=file)

        if extensions:
            print(file=file)
            print('#define SG_GL_HASEXTS 1', file=file)
            for n, extension in enumerate(extensions):
                print('#define SG_GL_{2} ((sg_glext[{0}] & {1}u) != 0)'
                      .format(n // 32, 1 << (n & 31), extension), file=file)

        print(file=file)
        glext = ''
        file.write(COMMON_FOOTER)

    def _dump_data(self, file, versions, extensions, command_list):
        file.write(NOTICE)
        print(file=file)

        file.write(
            'const unsigned char SG_GL_VERSIONS[{}] = {{\n'
            '    {}\n'
            '}};\n'
            '\n'
            .format(len(versions),
                    ',\n    '.join(
                        ', '.join(encode_version(v) for v in versions[i:i+8])
                        for i in range(0, len(versions), 8))))

        print('const char SG_GL_ENTRYNAME[] =', file=file)
        for command in command_list:
            print('"{}\\0"'.format(command), file=file)
        print(';', file=file)

        if extensions:
            print(file=file)

            print('const char SG_GL_EXTENSIONNAME[] =',
                  file=file)
            for extension in extensions:
                print('"{}\\0"'.format(extension), file=file)
            print(';', file=file)

    def _get_core(self, version, declare):
        if version not in self.features:
            raise ValueError('No such version: {}.{}'.format(*version))
        obj = CoreInterface(self, declare, version, self.profile)
        for fversion, feature in sorted(self.features.items()):
            for child in feature:
                prof = child.attrib.get('profile')
                if prof is not None and prof != self.profile:
                    continue
                if child.tag == 'require':
                    if fversion <= version:
                        obj._add(child)
                elif child.tag == 'remove':
                    obj._remove(child)
                else:
                    assert False
        return obj

    def _get_extension(self, name, declare):
        if name not in self.extensions:
            raise ValueError('No such extension: {}'.format(name))
        obj = ExtensionInterface(self, declare, name)
        for child in self.extensions[name]:
            api = child.attrib.get('api')
            if api is not None and api != self.api:
                continue
            prof = child.attrib.get('profile')
            if prof is not None and prof != 'core':
                continue
            if child.tag == 'require':
                obj._add(child)
            else:
                assert False
        return obj

class Interface(object):
    __slots__ = ['registry', 'commands', 'enums',
                 'filename', 'guard', 'namespace', 'flag',
                 'declare']

    def __init__(self, registry, declare):
        self.registry = registry
        self.commands = set()
        self.enums = set()
        self.declare = declare

    def _add(self, node):
        for child in node:
            if child.tag == 'command':
                self.commands.add(cmd_name(child.attrib['name']))
            elif child.tag == 'enum':
                self.enums.add(enum_name(child.attrib['name']))
            else:
                assert child.tag == 'type'

    def _remove(self, node):
        for child in node:
            if child.tag == 'command':
                self.commands.discard(cmd_name(child.attrib['name']))
            elif child.tag == 'enum':
                self.enums.discard(enum_name(child.attrib['name']))
            else:
                assert child.tag == 'type'

    def get_enums(self, previous):
        enums = set(self.enums)
        for iface in previous:
            enums.difference_update(iface.enums)
        enums = [(enum, self.registry.enums[enum]) for enum in enums]
        enums.sort(key=lambda x: sort_key(x[0]))
        return enums

    def get_commands(self, previous):
        cmds = set(self.commands)
        for iface in previous:
            cmds.difference_update(iface.commands)
        cmds = [(cmd, self.registry.commands[cmd]) for cmd in cmds]
        cmds.sort()
        return cmds

    def dump(self, file, previous, command_dict):
        file.write(NOTICE)
        file.write(IFACE_HEADER.format(info=self))
        for iface in previous:
            print('#include "{}"'.format(iface.filename), file=file)
        print('#ifdef __cplusplus', file=file)
        print('namespace {} {{'.format(self.namespace), file=file)
        for iface in previous:
            print('using namespace {};'.format(iface.namespace), file=file)
        print('#endif', file=file)

        enums = self.get_enums(previous)
        if enums:
            print(file=file)
            print('enum {', end='', file=file)
            tail = ''
            for name, value in enums:
                print(tail, file=file)
                print('    GL_{} = 0x{:04x}'.format(name, value),
                      end='', file=file)
                tail = ','
            print(file=file)
            print('};', file=file)

        commands = self.get_commands(previous)
        if commands:
            print(file=file)
            for name, command in commands:
                index = command_dict[name]
                template = (COMMAND_DIRECT if index is None
                            else COMMAND_INDIRECT)
                file.write(template.format(
                    type=command.proto.fulltype,
                    name=name,
                    params=', '.join(
                        '{0.fulltype} {0.name}'.format(p)
                        for p in command.params) or 'void',
                    retstmt=
                    'return ' if command.proto.fulltype != 'void' else '',
                    ptypes=
                    ', '.join(p.fulltype for p in command.params) or 'void',
                    pnames=', '.join(p.name for p in command.params),
                    index=command_dict[name],
                ))

        print(file=file)
        file.write(IFACE_FOOTER)

class CoreInterface(Interface):
    __slots__ = ['version']

    def __init__(self, registry, declare, version, profile):
        super(CoreInterface, self).__init__(registry, declare)
        self.version = version

        version = '{0[0]}_{0[1]}'.format(self.version)
        if profile != 'core':
            version = '{}_{}'.format(version, profile)
        self.filename = '{}.h'.format(version)
        self.guard = 'SG_GL_{}'.format(version.upper())
        self.namespace = 'gl_{}'.format(version)
        self.flag = 'version_' + version

class ExtensionInterface(Interface):
    __slots__ = ['name']

    def __init__(self, registry, declare, name):
        super(ExtensionInterface, self).__init__(registry, declare)
        self.name = name

        self.filename = '{}.h'.format(name)
        self.guard = 'SG_GL_{}'.format(name)
        self.namespace = 'gl_{}'.format(name)
        self.flag = name

    def dump(self, file, previous, command_dict):
        super(ExtensionInterface, self).dump(file, [], command_dict)

def parse_interface(name):
    def die():
        raise ValueError('Invalid interface: {}'.format(name))
    fields = name.split(':')

    if fields[0] == 'ext':
        if len(fields) < 2:
            die()
        itype = 'ext'
        iinfo = fields[1]
        fields = fields[2:]
    else:
        version = fields[0].split('.')
        if len(version) != 2:
            die()
        try:
            x, y = version
            x = int(x)
            y = int(y)
            version = x, y
        except ValueError:
            die()
        itype = 'gl'
        iinfo = version
        fields = fields[1:]

    if len(fields) == 0:
        profile = 'core'
    elif len(fields) == 1:
        profile = fields[0]
    else:
        die()
    if profile not in ('core', 'compatibility'):
        die()

    return InterfaceName(itype, iinfo, profile)

def parse_version(x):
    i = x.index('.')
    return int(x[:i]), int(x[i+1:])

def parse_api(s):
    i = s.find(':')
    if i >= 0:
        return s[:i], s[i+1:]
    return s, None
